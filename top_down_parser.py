#!/usr/bin/python
# -*- coding: utf-8 -*-
import re
import copy
import sys
import io

RULES_FILE = 'data/rules.txt'

class State:
	def __init__(self, production, pos):
		self.symbols = production
		self.pos = pos

class DictList(dict):
	'''
	Make a custom dict which can store duplicate key-values in list
	'''
	def __setitem__(self, key, value):
		try:
			self[key]
		except KeyError:
			super(DictList, self).__setitem__(key, [])
		self[key].append(value)

class TopDownParser:
	def __init__(self):
		self.rules = None
		self.terminals = None
		self.choices = {}	# Used to keep track of our choices on each non-terminal symbol

	def loadRules(self, rulesfile):
		'''
		Load rules into a dict and record the terminals with a set.
		Note that we define terminal symbols based on whether it can
		generate actual words.
		'''
		self.rules = DictList()
		terminals = []
		inRules = False
		inTerminals = False
		with open(rulesfile) as f:
			for line in f:				
				if line.strip() == '':
					continue	
				elif line.startswith('#BEGIN RULE'):
					inRules = True
				elif line.startswith('#END RULE'):
					inRules = False
				elif line.startswith('#BEGIN TERMINAL'):
					inTerminals = True
				elif line.startswith('#END TERMINAL'):
					inTerminals = False
				elif inRules:
					head, body = re.split('->', line.strip())
					self.rules[head.strip()] = body.split()
				elif inTerminals:
					head, body = re.split('->', line.strip())
					self.rules[head.strip()] = body.strip().split('|')
					terminals.append(head.strip())
		self.terminals = set(terminals)

	def findRules(self, symbol):
		return self.rules[symbol]

	def checkWordInSymbol(self, word, symbol):
		'''
		Check if this word can be generated by the given symbol's production
		'''
		for rule in self.rules[symbol]:
			if word in rule:
				return True
		return False

	def printParseTree(self):
		'''
		Construct the parse string using a helper method and some tricks
		(redirect stdout to a StringIO object temporally)
		'''
		sys.stdout = mystdout = io.StringIO()
		self.printParseTreeAux('S', self.choices, self.rules)
		parseString = mystdout.getvalue()
		sys.stdout = sys.__stdout__
		mystdout.close()
		return parseString

	# @param symbol, a non-terminal symbol
	# @param choices, a dict which records which choices we made during the parsing process
	# @param rules, a dict of rules 
	# @return nothing
	def printParseTreeAux(self, symbol, choices, rules):
		'''
		Choices mean which production we selected, eg. there are two productions for symbol 'NP':
			NP -> art n, NP -> art adj n
		Choices['NP'] = 1 means we select the #1(zero-based) production which is NP -> art adj n
		With this information in hand, we can simply backtrack from the 'S' symbol to construct the parse string.
		'''
		if choices[symbol] == -1:
			print(symbol + '(' + '|'.join(rules[symbol][0]) + ')', end='')
		else:
			c = choices[symbol]
			print(symbol, end='')
			print('(', end='')
			for symbl in rules[symbol][c]:
				self.printParseTreeAux(symbl, choices, rules)
			print(')', end='')

	def parse(self, sentence):
		stack = []
		succeed = False
		failed = False
		# Begin with the START symbol
		currState = State(['S'], 1)
		while not succeed and not failed:

			if not currState.symbols and currState.pos == len(sentence)+1:
				return True
			elif (not currState.symbols and not stack and currState.pos != len(sentence)+1) or (currState.pos == len(sentence)+1):
				return False

			# First symbol of this production
			s1 = currState.symbols[0]
			if (s1 in self.terminals) and self.checkWordInSymbol(sentence[currState.pos-1], s1):
				# If s1 is a terminal and it matches current word, create new state by removing
				# s1, updating the word position 
				del currState.symbols[0] 
				currState.pos += 1
				self.choices[s1] = -1 	# Set terminal marker used to build the parse tree

			elif s1 not in self.terminals:
				# If this is a non-terminal, expand s1 with its production and push possible alternatives to stack
				rules = self.findRules(s1)
				if len(rules) > 1:
					oldState = copy.deepcopy(currState)
				if rules is not None:
					# Record our choices which will be used to build the parse tree
					if s1 in self.choices:
						self.choices[s1] += 1
					else:
						self.choices[s1] = 0

					del currState.symbols[0]
					currState = State(rules[0] + currState.symbols, currState.pos)
					# Push candidates into stack
					if len(rules) > 1:
						del oldState.symbols[0]
						for i in range(1, len(rules)):
							stack.append((State(rules[i] + oldState.symbols, oldState.pos), s1))
			elif stack:
				# If current state is empty, and the sentence not yet exhausted, backtrack!
				currState, s1 = stack.pop()
				if s1 in self.choices:
					self.choices[s1] += 1
				else:
					self.choices[s1] = 0
			else:
				failed = True

def main():
	sentence = ['the', 'old', 'man', 'cried']
	parser = TopDownParser()
	parser.loadRules(RULES_FILE)
	succeed = parser.parse(sentence)

	if succeed:
		print('Succeed')
		print(parser.printParseTree())
	else:
		print('Failed')

if __name__ == '__main__':
	main()